"use strict";(self.webpackChunkthreejs_learning=self.webpackChunkthreejs_learning||[]).push([[81],{2081:(E,p,i)=>{i.r(p),i.d(p,{SunModule:()=>N});var h=i(6895),g=i(4462),o=i(1571),w=i(727),b=i(4968),e=i(6682),C=i(7152);const M=["canvas"],P=[{path:"",component:(()=>{class t{constructor(n){this.elementRef=n,this.subscription=new w.w0}ngAfterViewInit(){const n=this.elementRef.nativeElement,l=this.canvasElement.nativeElement,s=new e.oAp(256),F=new e._am(.1,10,s),x=new e.jyz({vertexShader:"#define GLSLIFY 1\nout vec3 vPosition;\n\nvoid main() {\n  vPosition = position;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat permute(float x) {\n  return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p, s;\n\n  p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n\n  return p;\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4 C = vec4(0.138196601125011,  // (5 - sqrt(5))/20  G4\n  0.276393202250021,  // 2 * G4\n  0.414589803375032,  // 3 * G4\n  -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i = floor(v + dot(v, vec4(F4)));\n  vec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step(x0.yzw, x0.xxx);\n  vec3 isYZ = step(x0.zww, x0.yyz);\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n// i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp(i0, 0.0, 1.0);\n  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n\n//  x0 = x0 - 0.0 + 0.0 * C.xxxx\n//  x1 = x0 - i1  + 1.0 * C.xxxx\n//  x2 = x0 - i2  + 2.0 * C.xxxx\n//  x3 = x0 - i3  + 3.0 * C.xxxx\n//  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute(permute(permute(permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n\n  vec4 p0 = grad4(j0, ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4, p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n\n}\n\nfloat fbm(vec3 pos, float time) {\n  float timeStep = 100.0;\n  float iterationTime = time;\n  float iterationAmplitude = 1.0;\n  float iterationScale = 1.0;\n  float sumNoise = 0.0;\n  int iteration = 6;\n\n  for(int i = 0; i < iteration; i++) {\n    vec4 noiseSeed = vec4(pos, iterationTime);\n    noiseSeed *= iterationScale;\n\n    sumNoise += snoise(noiseSeed) * iterationAmplitude;\n\n    iterationTime += timeStep;\n    iterationAmplitude *= 0.9;\n    iterationScale *= 2.0;\n  }\n  return sumNoise;\n}\n\nin vec3 vPosition;\n\nuniform float uTime;\n\nvoid main() {\n  float time = uTime * 0.001;\n\n  // fluctuation\n  float noiseValue = fbm(vPosition * 4.0, time);\n\n  // spots\n  vec4 spotsSeed = vec4(vPosition * 2.0, time);\n  float spotValue = max(snoise(spotsSeed), 0.0);\n\n  gl_FragColor = vec4(noiseValue);\n  gl_FragColor *= mix(1.0, spotValue, 0.7);\n}\n",side:e.ehD,uniforms:{uTime:{value:0}}}),G=new e.Kj0(new e.Aip(1,32,32),x),d=new e.xsS;d.add(G);const c=new e.cPb(70,n.clientWidth/n.clientHeight,.01,10);c.position.z=2.3;const v=new e.jyz({vertexShader:"#define GLSLIFY 1\nout vec3 vPosition;\nout vec3 vNormal;\nout vec3 vEyeDirection;\nout vec3 vLayer0;\nout vec3 vLayer1;\nout vec3 vLayer2;\n\nuniform float uTime;\n\nmat2 rotate(float value) {\n  float dy = sin(value);\n  float dx = cos(value);\n  return mat2(dx, -dy, dy, dx);\n}\n\nvoid main() {\n  vPosition = position;\n  vNormal = normal;\n\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vEyeDirection = normalize(worldPosition.xyz - cameraPosition);\n\n  float time = uTime * 0.0002;\n\n  mat2 rotation0 = rotate(time);\n  vec3 p0 = position;\n  p0.yz = rotation0 * p0.yz;\n  vLayer0 = p0;\n\n  mat2 rotation1 = rotate(time * 1.1 + 10.0);\n  vec3 p1 = position;\n  p1.xz = rotation1 * p1.xz;\n  vLayer1 = p1;\n\n  mat2 rotation2 = rotate(time * 1.3 + 30.0);\n  vec3 p2 = position;\n  p2.xy = rotation2 * p2.xy;\n  vLayer2 = p2;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"#define GLSLIFY 1\nin vec3 vPosition;\nin vec3 vNormal;\nin vec3 vEyeDirection;\nin vec3 vLayer0;\nin vec3 vLayer1;\nin vec3 vLayer2;\n\nuniform samplerCube uCubeTexture;\n\nfloat fresnel(vec3 eye, vec3 worldNormal) {\n  return pow(1.0 + dot(eye, worldNormal), 3.0);\n}\n\nfloat sunBrightness() {\n  float sum = 0.0;\n  sum += textureCube(uCubeTexture, vLayer0).r;\n  sum += textureCube(uCubeTexture, vLayer1).r;\n  sum += textureCube(uCubeTexture, vLayer2).r;\n  sum *= 0.33;\n  return sum;\n}\n\nvec3 brightnessToColor(float b) {\n  b *= 0.25;\n  return (vec3(b, pow(b, 2.0), pow(b, 4.0)) / 0.3) * 0.8;\n}\n\nvoid main() {\n  float edgeGlow = fresnel(vEyeDirection, vNormal);\n\n  float brigtness = sunBrightness();\n  brigtness = brigtness * 4.0 + 1.0;\n  brigtness += pow(edgeGlow, 0.4);\n\n  vec3 color = brightnessToColor(brigtness);\n  gl_FragColor = vec4(color, 1.0);\n}\n",side:e.ehD,uniforms:{uTime:{value:0},uCubeTexture:{value:null}}}),f=new e.Kj0(new e.Aip(1,32,32),v),I=new e.jyz({vertexShader:"#define GLSLIFY 1\nout vec3 vNormal;\n\nvoid main() {\n  vNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"#define GLSLIFY 1\nin vec3 vNormal;\n\nvec3 brightnessToColor(float b) {\n  b *= 0.25;\n  return (vec3(b, pow(b, 2.0), pow(b, 4.0)) / 0.3) * 0.6;\n}\n\nvoid main() {\n  float radial = 1.0 - vNormal.z;\n  radial = pow(radial, 3.0);\n\n  float brigtness = 1.0 + radial * 0.83;\n\n  gl_FragColor.rgb = brightnessToColor(brigtness) * radial;\n  gl_FragColor.a = radial;\n}\n",side:e._Li,transparent:!0}),Y=new e.Kj0(new e.Aip(1.2,32,32),I),u=new e.xsS;u.add(f),u.add(Y);const r=new e.CP7({canvas:l,antialias:!0});r.setSize(n.clientWidth,n.clientHeight),r.setClearColor("#000"),r.setAnimationLoop(function D(){m++,f.rotation.y=6e-4*m,x.uniforms.uTime.value=m,v.uniforms.uTime.value=m,F.update(r,d),v.uniforms.uCubeTexture.value=s.texture,r.render(u,c)}),this.renderer=r;const y=new C.z(c,this.renderer.domElement);y.target.set(0,0,0),y.update(),this.subscription.add((0,b.R)(window,"resize").subscribe(()=>{c.aspect=n.clientWidth/n.clientHeight,c.updateProjectionMatrix(),r.setSize(n.clientWidth,n.clientHeight)}));let m=0}ngOnDestroy(){this.subscription.unsubscribe(),this.renderer.setAnimationLoop(null)}}return t.\u0275fac=function(n){return new(n||t)(o.Y36(o.SBq))},t.\u0275cmp=o.Xpm({type:t,selectors:[["app-template"]],viewQuery:function(n,l){if(1&n&&o.Gf(M,5,o.SBq),2&n){let s;o.iGM(s=o.CRH())&&(l.canvasElement=s.first)}},decls:2,vars:0,consts:[[1,"canvas"],["canvas",""]],template:function(n,l){1&n&&o._UZ(0,"canvas",0,1)},styles:["[_nghost-%COMP%]{position:relative;height:100%;display:grid;place-items:center;background-color:#181818;overflow:hidden}.canvas[_ngcontent-%COMP%]{display:block;width:100%;height:100%}"]}),t})()}];let N=(()=>{class t{}return t.\u0275fac=function(n){return new(n||t)},t.\u0275mod=o.oAB({type:t}),t.\u0275inj=o.cJS({imports:[h.ez,g.Bz.forChild(P)]}),t})()}}]);