"use strict";(self.webpackChunkthreejs_learning=self.webpackChunkthreejs_learning||[]).push([[826],{2144:(L,d,i)=>{i.d(d,{V:()=>y});class y{static randomFloat(s,t){return s+Math.random()*(t-s)}static randomSign(){return Math.random()>.5?1:-1}static randomGaussian(s=0,t=1){const z=1-Math.random(),m=Math.random();return Math.sqrt(-2*Math.log(z))*Math.cos(2*Math.PI*m)*t+s}static randomRadian(){return Math.random()*Math.PI*2}static degreeToRadian(s){return Math.PI/180*s}}},5826:(L,d,i)=>{i.r(d),i.d(d,{Galaxy2Module:()=>H});var y=i(6895),C=i(4462),s=i(5861),t=i(1571),z=i(727),m=i(4968),P=i(2144),n=i(6682),j=i(7152);const Y=["canvas"],O=[{path:"",component:(()=>{class c{constructor(e){this.elementRef=e,this.subscription=new z.w0}ngAfterViewInit(){var e=this;return(0,s.Z)(function*(){yield new Promise(o=>setTimeout(o));const a=e.elementRef.nativeElement,g=e.canvasElement.nativeElement,x=a.getBoundingClientRect(),K={particle:(new n.dpR).load("assets/textures/glow-circle.jpg")},R=new n.iMs,h=new n.FM8,w=new n.Pa4(-20,0,20),U=new n.Kj0(new n.BKK(10,10,10,10).rotateX(-Math.PI/2),new n.vBJ({color:"#f00",wireframe:!0})),r=new n.cPb(65,a.clientWidth/a.clientHeight,.01,1e3);r.position.set(0,.7,2);const b=new n.xsS,G=[],E=new n.BKK(1,1);[{minRadius:.4,maxRadius:1.5,amplitude:1,color:"#FFAC41",size:.6},{minRadius:.3,maxRadius:1.5,amplitude:3,color:"#FFF",size:.3}].forEach(o=>function V(o){const S=o.minRadius,p=o.maxRadius,v=new n.L5s;v.instanceCount=5e3,v.setAttribute("position",E.getAttribute("position")),v.index=E.index;const F=new n.lb7(new Float32Array(15e3),3,!1);for(let M=0;M<5e3;M++){const I=P.V.randomRadian(),T=n.M8C.lerp(S,p,Math.random());F.setXYZ(M,T*Math.sin(I),.2*P.V.randomFloat(-.5,.5),T*Math.cos(I))}v.setAttribute("instancePosition",F);const A=new n.jyz({vertexShader:'#define GLSLIFY 1\nin vec3 instancePosition;\n\nout vec2 vUv;\n\nuniform float uTime;\nuniform float uSize;\nuniform float uAmplitude;\nuniform vec3 uMouse;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x * 34.0) + 10.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nvec3 fbm_vec3(vec3 p, float frequency, float offset) {\n  return vec3(cnoise((p + vec3(offset)) * frequency), cnoise((p + vec3(offset + 20.0)) * frequency), cnoise((p + vec3(offset - 30.0)) * frequency));\n}\n\nvec3 getOffset(vec3 p) {\n  float time = uTime * 0.001;\n  float twistScale = cnoise(instancePosition); // -1 .. 1\n  twistScale = twistScale * 0.5 + 0.5; // 0 .. 1\n  float minTwist = 0.1;\n  float twistRange = 0.2 * twistScale;\n\n  vec3 tempPosition = rotation3dY(time * (minTwist + twistRange) + length(instancePosition.xz)) * p;\n  vec3 offset = fbm_vec3(tempPosition, 0.45, 0.0);\n  return offset * 0.2 * uAmplitude;\n}\n\nvoid main() {\n  vUv = position.xy + vec2(0.5);\n\n  float particleSize = cnoise(instancePosition * 2.0); // -1 .. 1\n  particleSize = particleSize * 0.5 + 0.5; // 0..1\n  particleSize = particleSize * 0.1 + 0.005; // 0.005 .. particleSize*0.1\n\n  float particleRotationSpeed = uTime * 0.005 * (0.01 + 1.4 * particleSize);\n\n  vec3 worldPosition = rotation3dY(particleRotationSpeed) * instancePosition;\n\n  vec3 offset0 = getOffset(worldPosition);\n  vec3 offset = fbm_vec3(worldPosition + offset0, 0.0, 0.0);\n\n  vec3 particlePosition = (modelMatrix * vec4(worldPosition + offset0 + offset, 1.0)).xyz;\n\n  float mouseDistance = length(uMouse.xz - particlePosition.xz);\n  float mouseEffect = 1.0 - clamp(mouseDistance - 0.3, 0.0, 1.0);\n  mouseEffect = pow(mouseEffect, 4.0);\n\n  vec3 mouseEffectDir = particlePosition - uMouse;\n  vec3 mouseEffectPosition = uMouse + normalize(mouseEffectDir) * 0.1;\n  particlePosition = mix(particlePosition, mouseEffectPosition, mouseEffect);\n\n  vec4 viewPosition = viewMatrix * vec4(particlePosition, 1.0);\n  viewPosition.xyz += position * uSize * particleSize;\n\n  gl_Position = projectionMatrix * viewPosition;\n}\n',fragmentShader:"#define GLSLIFY 1\nin vec2 vUv;\n\nuniform sampler2D uTexture;\nuniform vec3 uColor;\n\nvoid main() {\n  vec4 texture = texture2D(uTexture, vUv);\n\n  gl_FragColor = vec4(uColor, texture.r);\n}\n",side:n.ehD,transparent:!0,depthTest:!1,uniforms:{uTime:{value:0},uMouse:{value:w},uSize:{value:o.size},uColor:{value:new n.Ilk(o.color)},uAmplitude:{value:o.amplitude},uTexture:{value:K.particle}}}),X=new n.Kj0(v,A);G.push(A),b.add(X)}(o));const l=new n.CP7({canvas:g,antialias:!0});l.setSize(a.clientWidth,a.clientHeight),l.setClearColor("#000"),l.setAnimationLoop(function W(o){G.forEach(f=>{f.uniforms.uTime.value=o,f.uniforms.uMouse.value=w}),l.render(b,r)}),e.renderer=l,new j.z(r,e.renderer.domElement).update(),e.subscription.add((0,m.R)(window,"resize").subscribe(()=>{r.aspect=a.clientWidth/a.clientHeight,r.updateProjectionMatrix(),l.setSize(a.clientWidth,a.clientHeight)})),e.subscription.add((0,m.R)(a,"mousemove").subscribe(o=>{const S=o.clientY-x.top;h.x=(o.clientX-x.left)/x.width*2-1,h.y=-S/x.height*2+1,R.setFromCamera(h,r);const p=R.intersectObjects([U])[0];p&&w.copy(p.point)}))})()}ngOnDestroy(){this.subscription.unsubscribe(),this.renderer.setAnimationLoop(null)}}return c.\u0275fac=function(e){return new(e||c)(t.Y36(t.SBq))},c.\u0275cmp=t.Xpm({type:c,selectors:[["app-galaxy-2"]],viewQuery:function(e,a){if(1&e&&t.Gf(Y,5,t.SBq),2&e){let g;t.iGM(g=t.CRH())&&(a.canvasElement=g.first)}},decls:2,vars:0,consts:[[1,"canvas"],["canvas",""]],template:function(e,a){1&e&&t._UZ(0,"canvas",0,1)},styles:["[_nghost-%COMP%]{position:relative;height:100%;display:grid;place-items:center;background-color:#181818;overflow:hidden}.canvas[_ngcontent-%COMP%]{display:block;width:100%;height:100%}"]}),c})()}];let H=(()=>{class c{}return c.\u0275fac=function(e){return new(e||c)},c.\u0275mod=t.oAB({type:c}),c.\u0275inj=t.cJS({imports:[y.ez,C.Bz.forChild(O)]}),c})()}}]);